const DEFAULT_FONT = [
  0x000f, 0x0808, 0x080f, 0x0808, 0x08f8, 0x0808, 0x00ff, 0x0808,
  0x0808, 0x0808, 0x08ff, 0x0808, 0x00ff, 0x1414, 0xff00, 0xff08,
  0x1f10, 0x1714, 0xfc04, 0xf414, 0x1710, 0x1714, 0xf404, 0xf414,
  0xff00, 0xf714, 0x1414, 0x1414, 0xf700, 0xf714, 0x1417, 0x1414,
  0x0f08, 0x0f08, 0x14f4, 0x1414, 0xf808, 0xf808, 0x0f08, 0x0f08,
  0x001f, 0x1414, 0x00fc, 0x1414, 0xf808, 0xf808, 0xff08, 0xff08,
  0x14ff, 0x1414, 0x080f, 0x0000, 0x00f8, 0x0808, 0xffff, 0xffff,
  0xf0f0, 0xf0f0, 0xffff, 0x0000, 0x0000, 0xffff, 0x0f0f, 0x0f0f,
  0x0000, 0x0000, 0x005f, 0x0000, 0x0300, 0x0300, 0x3e14, 0x3e00,
  0x266b, 0x3200, 0x611c, 0x4300, 0x3629, 0x7650, 0x0002, 0x0100,
  0x1c22, 0x4100, 0x4122, 0x1c00, 0x2a1c, 0x2a00, 0x083e, 0x0800,
  0x4020, 0x0000, 0x0808, 0x0800, 0x0040, 0x0000, 0x601c, 0x0300,
  0x3e41, 0x3e00, 0x427f, 0x4000, 0x6259, 0x4600, 0x2249, 0x3600,
  0x0f08, 0x7f00, 0x2745, 0x3900, 0x3e49, 0x3200, 0x6119, 0x0700,
  0x3649, 0x3600, 0x2649, 0x3e00, 0x0024, 0x0000, 0x4024, 0x0000,
  0x0814, 0x2241, 0x1414, 0x1400, 0x4122, 0x1408, 0x0259, 0x0600,
  0x3e59, 0x5e00, 0x7e09, 0x7e00, 0x7f49, 0x3600, 0x3e41, 0x2200,
  0x7f41, 0x3e00, 0x7f49, 0x4100, 0x7f09, 0x0100, 0x3e49, 0x3a00,
  0x7f08, 0x7f00, 0x417f, 0x4100, 0x2040, 0x3f00, 0x7f0c, 0x7300,
  0x7f40, 0x4000, 0x7f06, 0x7f00, 0x7f01, 0x7e00, 0x3e41, 0x3e00,
  0x7f09, 0x0600, 0x3e41, 0xbe00, 0x7f09, 0x7600, 0x2649, 0x3200,
  0x017f, 0x0100, 0x7f40, 0x7f00, 0x1f60, 0x1f00, 0x7f30, 0x7f00,
  0x7708, 0x7700, 0x0778, 0x0700, 0x7149, 0x4700, 0x007f, 0x4100,
  0x031c, 0x6000, 0x0041, 0x7f00, 0x0201, 0x0200, 0x8080, 0x8000,
  0x0001, 0x0200, 0x2454, 0x7800, 0x7f44, 0x3800, 0x3844, 0x2800,
  0x3844, 0x7f00, 0x3854, 0x5800, 0x087e, 0x0900, 0x4854, 0x3c00,
  0x7f04, 0x7800, 0x447d, 0x4000, 0x2040, 0x3d00, 0x7f10, 0x6c00,
  0x417f, 0x4000, 0x7c18, 0x7c00, 0x7c04, 0x7800, 0x3844, 0x3800,
  0x7c14, 0x0800, 0x0814, 0x7c00, 0x7c04, 0x0800, 0x4854, 0x2400,
  0x043e, 0x4400, 0x3c40, 0x7c00, 0x1c60, 0x1c00, 0x7c30, 0x7c00,
  0x6c10, 0x6c00, 0x4c50, 0x3c00, 0x6454, 0x4c00, 0x0836, 0x4100,
  0x0077, 0x0000, 0x4136, 0x0800, 0x0201, 0x0201, 0x704c, 0x7000
];

const DEFAULT_PALETTE = [
  0x000, 0x00a, 0x0a0, 0x0aa, 0xa00, 0xa0a, 0xa50, 0xaaa,
  0x555, 0x55f, 0x5f5, 0x5ff, 0xf55, 0xf5f, 0xff5, 0xfff
];

export default class Monitor {
  constructor(emulator, canvas) {
    this.emulator = emulator

    this.canvas        = canvas
    this.canvas.width  = 128
    this.canvas.height = 96
    this.context       = canvas.getContext('2d');
    this.imageData     = this.context.createImageData(
      this.canvas.width,
      this.canvas.height
    )

    this.id           = 0x7349f615
    this.version      = 0x1802
    this.manufacturer = 0x1c6c8b36
    this.connected    = false

    setTimeout(this.render.bind(this), 1000 / 30)
  }

  init() {
    this.connected = false
  }

  interrupt() {
    let code  = this.emulator.Registers.A.get()
    let value = this.emulator.Registers.B.get()

    switch(code) {
      case 0:
        if(value === 0) {
          this.disconnect()
        } else {
          this.memMapScreen(value)
        }
        break
      default:
        console.warn("Unimplemented interrupt:", code, value)
    }
  }

  memMapScreen(value) {
    this.memOffset = value
    this.connected = true
  }

  drawCell(x, y, word) {
    let glyph = word & 0x7f
    let blink = (word & 0x0080) >> 7
    let bg    = (word & 0x0f00) >> 8
    let fg    = (word & 0xf000) >> 12
    this.drawGlyph(x, y, glyph, fg, bg, blink)
  }

  drawGlyph(x, y, glyph, fg, bg, blink) {
    // load font data
    let cols = [];
    glyph *= 2;
    cols[0] = this.readFont(glyph) >> 8
    cols[1] = this.readFont(glyph) & 0xff
    cols[2] = this.readFont(glyph + 1) >> 8
    cols[3] = this.readFont(glyph + 1) & 0xff

    // load colour data
    let bgSplit = this.readColours(bg)
    let [bgR, bgG, bgB] = bgSplit
    let fgSplit = this.readColours(fg)
    let [fgR, fgG, fgB] = fgSplit

    // draw glyph to buffer
    for(let row = 0; row < 8; row++) {
      for(let col = 0; col < 4; col++) {
        let bit = (cols[col] >> row) & 0x01
        let index = ((x*4 + col) + (y*8 + row) * this.canvas.width) * 4
        if(bit == 1) {
          this.imageData.data[index+0] = fgR
          this.imageData.data[index+1] = fgG
          this.imageData.data[index+2] = fgB
          this.imageData.data[index+3] = 255
        } else {
          this.imageData.data[index+0] = bgR
          this.imageData.data[index+1] = bgG
          this.imageData.data[index+2] = bgB
          this.imageData.data[index+3] = 255
        }
      }
    }
  }

  readFont(offset) {
    // TODO read font when memory mapped
    return DEFAULT_FONT[offset]
  }

  readColours(index) {
    // TODO read palette when memory mapped
    let colour = DEFAULT_PALETTE[index]

    let r = ((colour & 0xf00) >> 8) * 16
    let g = ((colour & 0x0f0) >> 4) * 16
    let b = (colour & 0x00f) * 16

    return [r, g, b]
  }

  renderToBuffer() {
    // draw glyphs to buffer
    for(let y = 0; y < 12; y++) {
      for(let x = 0; x < 32; x++) {
        let word = this.emulator.RAM[this.memOffset + x + y * 32]
        this.drawCell(x, y, word)
      }
    }
  }

  renderToCanvas() {
    // draw buffer to canvas
    this.context.putImageData(this.imageData, 0, 0)
  }

  render() {
    if (this.connected) {
      this.renderToBuffer()
      requestAnimationFrame(this.renderToCanvas.bind(this))
    }
    setTimeout(this.render.bind(this), 1000 / 30)
  }
}
